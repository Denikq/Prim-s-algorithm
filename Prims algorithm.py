# Алгоритм Прима
# Пошук мінімального кістякового дереве для зваженого зв'язного неорієнтованого графа

import math

# граф G як список суміжності із зазначенням ваг

# приклад 1
# G = [(math.inf, -1, -1), (3, 0, 1),(9, 0, 2), (11, 2, 1), (1, 2, 3), (13, 1, 3), (3, 3, 4)]

# приклад 2
# G = [(math.inf, -1, -1), (4, 0, 4), (8, 5, 4), (7, 4, 2), (3, 5, 2), (9, 5, 3), (11, 3, 2), (8, 2, 6), (5, 3, 6)]

# приклад 3
G = [(math.inf, -1, -1), (10, 0, 4), (8, 4, 3), (11, 0, 3), (17, 0, 1), (13, 4, 2), (28, 3, 2), (23, 3, 1), (18, 1, 2), (15, 2, 5), (14, 1, 5)]

Vt = {0} # множина з'єднаних вузлів як вибраний початковий вузол 

Et = [] # список дуг, які складаються мінімальне кістьове дерево для графа G

# функція для пошуку вузла з мінімальною вагою на приєднаній дузі

def get_min(G, Vt):

    # res як дуга з "нескінченною" вагою
    res = (math.inf, -1, -1)

    for v in Vt:

        # пошук вузла з'єднання з мінімальною вагою, причому такого щоб не було циклів
        minimum = min(G, key = lambda x: x[0] if (x[1] == v or x[2] == v) and (x[1] not in Vt or x[2] not in Vt) else math.inf)

        # якщо вага дуги менша за "нескінченність"
        if res[0] > minimum[0]:
            res = minimum

    return res


# умова циклу: кількість з'єднаних вершин менша за кількість елементів списку G
# вихід із циклу: немає вузла, що не зв'язаний із кістяком

while len(Vt) < len(G):
    # виклик функції get_min
    new = get_min(G, Vt)

    # якщо нового елемена не знайдено

    if new[0] == math.inf:
        break

    # додавання  відповідних знайдених елементів у масив вузлів Vt та вихідний список Et
    Et.append(new)
    Vt.add(new[1])        
    Vt.add(new[2])

# виведення кістьового дерева у вигляді списку
print(Et)


